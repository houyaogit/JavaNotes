# Java并发编程实战



## 1 线程带来的安全问题

- 安全性、 活跃性、 性能问题

  ``` 
  如何设计 线程安全的 Servlet 和 RMI（远程调用方法）
  servlet 是需要线程安全的
  ```



## 2 线程的安全性

### 2.1 对可变的、共享的状态的访问 -（ atomiclong synchronized ）

- 三种解决方法 ： 

```
a.不在线程间使用变量（数据）  
b.将状态设置为不可变的  
c.在访问状态变量时使用同步。
```

### 2.2 何为线程安全

``` 
a 在多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在 主调代码中不需要任何额外的同步或协同，这个类都能表现出正常的行为，就称这个类是线程安全的。
b 尽量使用线程安全的对象 如：AtomicLong ,
c 无状态对象一定是线程 安全的，
```

### 2.3  加锁机制

- synchronized 监视器锁、 内置锁、互斥锁
- 重入

``` 
（线程试图获取一个已经由它自己持有的锁），意味着获取锁的操作的粒度是 “线程” 而不是“调用”，
： 解决方法。为每个锁 关联一个 计数值 （0 1 0） 。 
```

### 2.4 用锁来保护状态

- 每个共享和可变的变量 都只能由一个锁来保护
- 如果多个锁会怎样呢， ？？？？ 锁及失效

### 2.5 活跃性与性能

- 不能为了性能而失去简单性
- 当计算时间较长的计算或者可能无法快速完成的操作（网络I/O、控制台I/O），一定不要持有锁



## 3 线程的可见性

### 3.1 可见性

- java 内存模型

  ``` 
  规则1.所有的变量都存储在主内存中，每个线程都有自己独立的内存，里面保存该线程使用到的变量的副本（主内存拷贝）
  规则2.线程的操作在自己的工作内存中，不同线程之间无法访问其他线程内存中的变量，需要通过主内存同步。
  ```

  模型图如下：

  ![image-20200614233051606](image-20200614233051606.png)

Volatile 变量，返回最新的值，可见性 （load ，store）。

JMM关于Synchronize的两条规则：

``` 
1.线程解锁前：将线程内存中的变量写入主内存中
2.线程加锁时：清空线程中共享变量的值，重新从主内存中copy一份，
```

导致线程不可见的原因：

``` 
线程的交叉执行
指令重排序 结合 交叉
工作内存中的值没有及时刷新到主内存中
```

解决方案

- 确保 写线程 在 读线程 之前完成，

  volatile作用； 在被线程读的时候重新从主内存中读取，当被线程写的时候强迫线程将最新的值刷进主内存。（）

synchronized 和 volatile 的区别：

``` 
1.volatile不需要加锁 比synchronzed 更轻量级，不会阻塞线程
2.volatile写 = 解锁退出synchronized ， volatile读 = 获取synchroinzed锁 
3.synchronized 既能保证内存可见性又能保证原子性， volatile只能保证内存可见性
```



### 3.2 发布 和 逸出， 

- 发布：对像能够在当前作用域之外的代码中使用。 
- 逸出：不该发布的时候被发布。

### 3.3 线程封闭： ThreadLocal 

### 3.4 不变性

### 3.5 安全发布：发布对象放入线程安全的容器中再取出， 即可实现安全的发布

``` 
a. 放入HashTable、SyncMap、ConcurrentMap中
b. 放入Vector、SyncList、SyncSet中
c. 放入 BlockingQueue 、 ConcurrentLinkedQueue中
```



## 4 设计线程安全的类

### 4.1 不可变的对象 或者 由锁保护的对象。 

* servletContext 为servlet 提供了类似Map形式的对象容器

### 4.2 设计安全的Servlet 和 RMI 

``` 
a 同步共享的数据，
b 不使用实例变量
```



## 5 并发容器

- BlockingQueue、 ConcurrentHashMap 分段锁

### 5.1 阻塞队列 和 生产者-消费者 模式

### 5.2 同步工具类： 信号量、 栅栏、闭锁

``` 
1. 闭锁： CoountDownLatch  await() 阻塞 、等待 CountDown()  -1 。
2. FutureTask 可生成结果计算
3. Semaphore 信号量 用来控制同时访问某个特定资源的操作数量。
4. 栅栏 ： 一定数量的参与方反复再栅栏位置汇聚（六点先集合 再出发、细胞算法）,另一种栅栏 Exchanger 数据交换
```

### 5.3 基于FutureTask 的记忆器 page 88



## 6 任务执行

1. 1. 在线程中执行任务， 串行& 并行

   2. 无限制创建线程的不足： 

   3. 1. 线程生命周期开销大
      2. 资源消耗
      3. 稳定性

   4. Executor框架 

   5. 1. 执行策略 将任务的执行与提交解偶 ，

      2. 线程池

      3. 1. newFixedThreadPool 固定长度的线程池
         2. newCachedThreadPool 可缓存的线程池
         3. newSingleThreadExecutor 单个线程池，线程挂掉再启一个，依旧按照队列中的顺序串行执行（如：FIFO、LIFO、优先级）
         4. newScheduledThreadPool. 固定长度、延迟或者定时的方式执行

      4. 为任务设置时限 future.get(时限)

   6. 

## 7 取消与关闭

1. 1. 取消： 用户请求取消、时间限制的操作、应用程序事件、错误、关闭

   2. 中断是实现取消最合理的方式

   3. 中断策略

   4. 1. 响应中断
      2. 计时运行
      3. 通过future 来实现取消
      4. 处理不可中断的阻塞

   5. “毒丸” 对象 ，放在队列上的对象，含义是遇到这个对象，立即停止， 在生产者消费者已知的情况下才可以使用毒丸，

   6. 处理非正常的线程终止： 栈追踪信息， 控制台能输出，但是日志无法输出 （throwable 查栈信息等）

   7. 

## 8 线程池的使用

1. 1. 线程饥饿死锁
   2. 设置线程池的大小：部署系统特性、CPU、资源预算、任务特性（IO密集型、计算密集型）

## 9 GUI 

1. 1. 

## 10 避免活跃性危险

1. 1. 死锁 （A线程等待B线程占用的资源）

   2. 1. 顺序死锁、 动态顺序死锁
      2. 写作对象之间发生的死锁
      3. 资源死锁

   3. 解决： 定时的锁

   4. 其他活跃性问题

   5. 1. 饥饿 （优先级使用不当）
      2. 糟糕的响应
      3. 活锁（重复执行相同的操作，还不断犯错）

   6. 

## 11 性能与可伸缩性

1. 1. CPU、内存、存储容量、IO带宽

   2. 以测试为基准，不要猜测

   3. Amdahl 定律， 加速比， 100个处理器加速比能达到9， 10处理器加速比5

   4. 线程引入的开销： 

   5. 1. 上下文切换、
      2. 内存同步： 
      3. 阻塞

   6. 减小锁的范围（快进快出）、 减小锁的粒度

   7. 1. 锁分段， 竞争激烈的锁可以分解为两个锁
      2. 避免热点域



## 12 并发程序的测试

1. 1. 正确性测试
   2. 性能测试
   3. 避免性能测试的陷阱



## 13 显式锁

1. 1. 内置锁无法满足的情况下使用ReentrantLock高级功能：定时、轮询、中断、公平、非块结构的锁。
   2. 读写锁



## 14 构建自定义的锁

1. 1. 一般内置类库及够用： countDownLatch 、 FutureTask、Semaphore、BlockingQueue 就够用了

   2. （中断、公平、时限）使用condition 对象、 内置的 **条件队列** 、（AQS）AbstractQueuedSynchronizer 框架

   3. 1. AQS：？？ （获取、释放）

   4. 使用条件队列  逻辑记入文档。

   5. 1. CountDownLatch ： 等待直到闭锁达到结束状体啊
      2. FutureTask ： 等待直到任务已经完成 （任务状态：尚未开始、正在运行、已经完成）
      3. Semaphore ： 剩余的许可数量
      4. ReentranLock ： 重复获取该锁的次数



## 15 原子变量和非阻塞同步机制

1. 1. 使用原子变量 构建非阻塞算法，（计数器、栈）

   2. 硬件对并发的支持

   3. 1. 比较并交换 （CAS）
      2. CAS算法 优于 基于锁的算法



## 16 Java 内存模型

1. 1. 每个处理器有自己的缓存，定期于主内存进行协调